* Writing
  :PROPERTIES:
  :VISIBILITY: children
  :END:

** Philosophy of Programming
   :PROPERTIES:
   :VISIBILITY: children
   :END:

*** Program vs. Process :: The World Is Not a Document


*** The Coder's Journey :: Programming Languages Are like Martial Arts


*** The Documentation Divide :: Separating the Beginners from the Experts


*** Staking Claims :: An Essay on the Nature and Significance of Software Community-Building


*** Dynamic Visual Alignment via Whitespace Edits

#+BEGIN_SRC racket
  #:with for/*mat-columns (format-id #'*mat  "for/~a-columns" #'*mat)
  #:with for*/*mat-columns (format-id #'*mat "for*/~a-columns" #'*mat)
#+END_SRC

vs

#+BEGIN_SRC racket
  #:with  for/*mat-columns (format-id #'*mat  "for/~a-columns" #'*mat)
  #:with for*/*mat-columns (format-id #'*mat "for*/~a-columns" #'*mat)
#+END_SRC

My routine:

1. Inject aligning whitespace to "open up" the code and align structural elements
  - syntactic patterns that reflect semantic patterns
  - e.g., above: `#:with` keywords, `/*mat-columns` suffix, parens around expression, ...
  - align columns of related syntax left or right
  - "weighted minimal edit distance" heuristic
2. Edit the code
3. Re-normalize whitespace to "pack up" the code for "storage."

<whitespace-routine.gif>

This could be automated. It was pretty common with Perl in the '90s.


** Data Economics
   :PROPERTIES:
   :VISIBILITY: children
   :END:

*** Social Computing
    :PROPERTIES:
    :VISIBILITY: children
    :END:

*** What's a FLOP Worth?


*** When the Map Becomes the Territory :: Establishing New Data Markets via Gamification


*** Data Flow
    :PROPERTIES:
    :VISIBILITY: children
    :END:

*** Where Code Meets Data :: The Art and Science of Dataflow Programming

**** What Is Flow?

Flow is a relation between space and time.

https://en.wikipedia.org/wiki/Flux

**** A Precise Definition

At a point ~x~ = (~x₁~, ~x₂~, …, ~xₙ~) and a time ~t~,

#+BEGIN_EXAMPLE
φᴺ = f(x,t)
#+END_EXAMPLE

where ~x~ is a point in an N-dimensional space and ~t~ is a scalar value, like a real number.

In practice, one of ~x~ or ~t~ remains fixed while the other varies.

#+BEGIN_EXAMPLE
φᴺ = f(x;t) ∪ f(t;x)
#+END_EXAMPLE

***** Zero-Dimensional Flow

A <<0-flow>> is a value.

#+BEGIN_EXAMPLE
φ⁰ = f|x=C₁,t=C₂
#+END_EXAMPLE

For all time and space, [[0-flow]] is constant.

***** One-Dimensional Flow

A <<1-flow>> is a unary function.

#+BEGIN_EXAMPLE
φ¹(x₁,t) = f(t;x₁=C₁) ∪ f(x₁;t=C₂)
#+END_EXAMPLE

When ~x₁~ = ~C₁~ a constant, [[1-flow]] ~f(t;x₁=C₁)~ characterizes the passage of
time at the fixed point ~x₁~ = ~C₁~ in a one-dimensional space. When ~t~ =
~C₂~ a constant, [[1-flow]] ~f(x₁;t=C₂)~ characterizes all the points in a
one-dimensional space at the fixed time ~t~ = ~C₂~.

***** Two-Dimensional Flow

A <<2-flow>> is a binary function.

#+BEGIN_EXAMPLE
φ²(x₁,x₂,t) = f(t;x₁=C₁,x₂=C₂) ∪ f(x₁,x₂;t=C₃)
#+END_EXAMPLE

When ~x₁~, ~x₂~ = ~C₁~, ~C₂~ constants, [[2-flow]] ~f(t;x₁=C₁,x₂=C₂)~
characterizes a line through space as time passes. At every point on the line,
[[2-flow] varies as time passes.

***** N-Dimensional Flow

A <<3-flow>> is a ternary function. At every point on a plane, [[3-flow]] varies with time.

...

An <<N-flow>> is an N-ary function. At any point in an (N-1)-dimensional
hypercube, [[N-flow]] varies with time.

A space has a fixed (but unbounded) number of dimensions. Each position in the
continuum of space can be uniquely identified by a vector of N-1 real numbers.
Time, on the other hand, is at most linear; it either remains constant or
progresses monotonically in one direction or the other. Time is an index into
a continuum of (N-1)-dimensional spaces.


** Graphics
   :PROPERTIES:
   :VISIBILITY: children
   :END:

*** #lang graphics-engine

**** Printing a Shader

#+BEGIN_SRC racket
#lang graphics-engine

(define-shader vertex-shader
  (#%version 330 core)
  (layout ([location 0]) in vec4 vPosition)
  (layout ([location 1]) in vec4 vColor)
  (out vec4 color)
  (uniform mat4 mvp)
  (define (main) : void
    (set! gl_Position (* mvp vPosition))
    (set! color vColor)))

(display (shader-string vertex-shader))
(exit)
#+END_SRC


*** Voxels Are for More Than Just Mining

**** Minecraft for Research

A paper titled /[[https://arxiv.org/abs/1909.10475][String Diagrams for Assembly Planning]]/ popped into my twitter
feed a couple weeks ago. It's interesting because the authors used a Minecraft
mod as part of their evaluation. They turned LEGO schematics into plans for
building things one piece at a time and then used Minecraft to watch the plans
execute in real time.

#+CAPTION: [[https://arxiv.org/abs/1909.10475][Figure 1: LEGO-CAD Model to Minecraft Simulation]]
[[./img/legocad-to-minecraft.png]]

[![Figure 1: LEGO-CAD Model to Minecraft Simulation](https://raw.githubusercontent.com/dedbox/dedbox.github.io/master/img/legocad-to-minecraft.png)](https://arxiv.org/abs/1909.10475)

There's more to it than that, but the Minecraft mod is what caught my attention.

The paper also cites another paper, *[Minecraft as an experimental world for ai in robotics](https://www.aaai.org/ocs/index.php/FSS/FSS15/paper/viewPDFInterstitial/11725/11518)*. This one argues that using their Minecraft mod⁠—*BurlapCraft*⁠—as a research platform reduces the cost of experimenting with artificial intelligence for robots in three ways:

1. Working in voxel space simplifies the development of experiments.
2. Domain-specific functionality is integrated into the environment.
3. Minecraft is popular and it has a gradual learning curve.

![Figure 11: When issued the language command 'go to the gold block', the agent mines the multi-colored block and places it on the lava to cross over and reach the gold block.](https://raw.githubusercontent.com/dedbox/dedbox.github.io/master/img/minecraft-ai-find-gold-block.png)

I was at that symposium. It's where I started thinking about the potential of high-level voxel programming for applications that don't fit the block mining paradigm.

# Voxels Beyond Minecraft

There's this great blog post, [How Voxels Became ‘The Next Big Thing’](https://medium.com/@EightyLevel/how-voxels-became-the-next-big-thing-4eb9665cd13a), that illustrates the power of using voxels as simple volumetric pixels instead of large, textured blocks. They make a compelling argument:

> Voxel-based representation is essential for creating massive shared interactive virtual environments that will, at some point, resemble the real world.

The way they're using multiple levels of detail (LODs) is pretty awesome; it allows them to render each frame in time proportional to the number of pixels in the output.

[![Atomontage - complex desert terrain in multiple LODs](https://miro.medium.com/max/1024/0*neeMlGo6inNWXUoL.jpg)](https://medium.com/@EightyLevel/how-voxels-became-the-next-big-thing-4eb9665cd13a)

For a fixed display resolution, the ratio of pixels to triangles diminishes rapidly as the complexity of the scene increases. The people at [Atomontage](https://www.atomontage.com/) have been exploiting this property to simulate complex textured surfaces as grids of solid-colored voxels with interesting physical properties.

# Language-Oriented Voxel Programming

Providing this kind of functionality as a Racket library would go a long way toward putting shared volumetric simulations into the hands of more programmers. A general-purpose voxel programming environment could support complex 3-D visualizations and simulations. It could offer scriptable cameras, a variety of regular grid structures, and the ability to operate at any effective scale. It could have a REPL for peeking and poking at things as they play out. Casual programmers should be able to simulate clouds with voxels rendered as tiny diffuse balls that move freely along an octahedral lattice and interact with each other as a fluid.

Voxel programming environments also have potential as a medium for growing effectively scale-invariant shared simulations. On a dual-core laptop with integrated graphics, I might be able to simulate the nearest few chunks comfortably. A desktop with four cores, hyper-threading, and a $200 graphics card might handle dozens more chunks in general, with options for pushing into the hundreds of chunks by off-loading calculations to the GPU. On a LAN, the laptop could become a dumb terminal that off-loads the entire simulation to the desktop. For simulations larger than the local network, distant chunks could be deployed to the cloud or more esoteric high-performance computing architectures. Imagine what could be simulated on a fully loaded Cray XC30!

Voxels have the potential to transform every trade, discipline, and industry they touch. The world is waiting for a general-purpose voxel programming environment and just doesn't know it yet.


*** Voxel-Space Programming



*** The OpenGL Math Library (GLM)
    :PROPERTIES:
    :VISIBILITY: children
    :END:

**** How Fast Is GLM for Racket?


**** Getting Started with GLM


**** Making GLM Faster




*** The OpenGL Shader Language (GLSL)
    :PROPERTIES:
    :VISIBILITY: children
    :END:

**** Introducing GLSL for Racket


**** Shader DSLs




** Functional Racket
   :PROPERTIES:
   :VISIBILITY: children
   :END:

*** Curry, Compose, Conjoin, Apply


*** Multi-Valued Expressions


*** Pattern Matching


*** Custom Printing and Equality Checks




** Racket Meta-Programming
   :PROPERTIES:
   :VISIBILITY: children
   :END:

*** Pattern-based Macros
    :PROPERTIES:
    :VISIBILITY: children
    :END:

**** Micro-DSLs :: Seize the Means of Construction!




*** Procedural Macros
    :PROPERTIES:
    :VISIBILITY: children
    :END:

**** Syntax Objects


**** syntax-parse and Optional Patterns


**** First-Order Macros
     :PROPERTIES:
     :VISIBILITY: children
     :END:

***** Transformer Bindings


***** Syntax Transformers


***** Compile-Time Structs




**** Higher-Order Macros
     :PROPERTIES:
     :VISIBILITY: children
     :END:

***** Recursive Macros :: Inside #lang GLSL


***** Macro Generation :: Just Another Kind of Term Rewriting


***** Syntax Parameters


***** Scopes and Module Boundaries




*** Whole-Program Transformations
    :PROPERTIES:
    :VISIBILITY: children
    :END:

**** Module-Level Keywords


**** Algebraic Data Types


**** Exhaustivity Checks


**** Totality Checks




*** Language-Oriented Programming
    :PROPERTIES:
    :VISIBILITY: children
    :END:

**** A #lang Primer


**** Simply-Typed Racket


**** Recur, Eval, Co-Recur :: DSLs for Data Formats


**** Like Bread and Butter :: #%module-begin and local-require


**** Meta-Languages Make a Mean Module Mix-in




** SCD
   :PROPERTIES:
   :VISIBILITY: children
   :END:
